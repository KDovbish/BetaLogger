package dk.betalogger;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;

/**
 * Абстрактный класс, на базе которого строяться все управляющие объекты очередей в бета-логере.
 * <br/><br/>
 * Техничеси, можно было бы, конечно, объединить классы QueueHandler и QueueHandlerEngine в один. Но, мне кажется, что поля
 * {@link #enable}, {@link #addToQueue}, {@link #threadRestartNeed} не являются обязательными для основных функций управления
 * очередью({@link QueueHandlerEngine}), т.к. эти поля не учавствуют в реализации механизма движка(старт, стоп, задержки, проверка запущенности потока).
 * Данный абстрактный класс нужен исключительно для реализации логики бета-логера.
 */
abstract class QueueHandler extends QueueHandlerEngine implements AddingToQueue {
    /**
     * Признак Работающий объект/Блокированный объект.<br/>
     * <br/>
     * Логика флага enable:
     * Если управляющий объект очереди был однажды создан(
     * {@link BetaLogger#setConsoleLogging()},
     * {@link BetaLogger#setFileLogging(String) setFileLogging()}
     * {@link BetaLogger#setDbLogging(DbType, String, String, String, String) setDbLogging()}), он более не удаляется.
     * Он может быть только заблокирован к использованию флагом enable. <br/>
     */
    @Getter(AccessLevel.PACKAGE) private boolean enable = false;

    void setEnable(boolean enable) {
        //  Разрешение объекта к использованию также автоматически разрешает добавление в очередь
        //  Блокировка объекта также автоматически блокирует добавление в очередь
        this.addToQueue = enable;
        this.enable = enable;
    }

    /**
     * Признак того, нужно ли производить добавление в очередь.<br/>
     * <br/>
     * В логирующую очередь может добавлять сообщения исключительно управляющий объект входной очереди. И этот управляющий объект входной очереди
     * "знает" в управляющем объекте логирующей очереди только метод offer(), который является реализацией интерфейса AddingToQueue.
     * Конечно, можно всегда снять с регистрации в управляющем объекте входной очереди управляющий объект логирующей очереди и этим прекратить
     * распределение сообщений в логирующую очередь.
     * Но возникла необходимость реализации логики восстановления после ошибки логирования в файл или базу данных. И здесь очень помогает флаг addToQueue.
     * Непосредственно сам(!) управляющий объект, обнаружив ошибку логирования, блокирует доступ новых сообщений в свою очередь до тех пор, пока ошибка не будет решена.
     * При этом для управляющего объекта входной очереди ничего не изменилось: он по прежему отправляет сообщения в управляющий объект логирующей очереди,
     * используя вызов метода offer().
     */
    @Getter @Setter private boolean addToQueue = false;

    /** Признак необходимости перезагрузки управляющего потока  */
    @Getter @Setter private boolean threadRestartNeed = false;

    /** Добавление нового сообщения в очередь */
    @Override
    public void offer(LogData logData) {
        if (enable && addToQueue) queue.offer(logData);
    }
}
